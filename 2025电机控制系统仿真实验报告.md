# 电机控制系统仿真实验报告

<center><div style='height:2mm;'></div><div style="font-family:华文楷体;font-size:14pt;">姓名   </div></center>
<center><span style="font-family:华文楷体;font-size:9pt">哈尔滨工程大学创梦之翼战队，电控组，邮箱<br /></span>



<font color=Blue>注意事项 ：</font>

<font color=Blue>1、应将所有蓝色字体删去作为最终上交的报告</font>。

<font color=Blue>2、可以参考优秀文章和相关资料，但是不能照抄</font>。

<font color=Blue>3、绿色字体标题内容为选做部分，其余为必做部分。</font>

<font color=Blue>4、注意：寒假第一次作业质量不合格者，将失去梯队队员资格！！！</font>

## 八字方针：建模 分析 设计 校验

### 一、建模

#### 1.1 确定传递函数形式

<font color=Blue>运用机理法，通过分析系统的数学物理关系，建立系统的数学模型，如微分方程，传递函数等。实验说明文档中已经给出了示例，可以参考文档，并添加自己的理解。把建模的过程写在这里。</font>

#### <font color=Green>1.2 确定传递函数参数</font>

<font color=Blue>运用实验法，向系统添加已知的输入，通过研究其响应确定传递函数参数。在这里填入传递函数参数，具体推导方法写在第五节。</font>

### 二、分析

<font color=Blue>利用根轨迹，伯德图等方法，分析开环系统的性能，如响应速度，超调大小，稳定性，稳态误差等。</font>

#### <font color=Green>2.1 系统开环传递函数根轨迹</font>

<font color=Blue>放一系列开环系统根轨迹的图片并做一定分析</font>

#### <font color=Green>2.2 系统开环传递函数伯德图</font>

<font color=Blue>放一系列开环系统伯德图并做一定分析</font>

### 三、设计

<font color=Blue>设计控制器，并调节参数，提高系统的控制性能，如加快响应速度，抑制超调，消除稳态误差等。</font>

#### 3.1 PID控制器的数学表达式

微分方程：
$$
u(t)=K_pe(t)+K_i\int e(t)dt+K_d\frac{de(t)}{dt}
$$
连续传递函数：
$$
G_\mathrm{}(s)=K_p+\frac{K_i}s+K_ds
$$
差分方程：
$$
u_k=u_{k-1}+K_p(e_k-e_{k-1})+K_ie_kT+K_d\frac{(e_k-2e_{k-1}+e_{k-2})}T
$$
离散传递函数：
$$
G_\mathrm{}(z)=K_p+K_i\frac T{z-1}+K_d\frac{z-1}{Tz}
$$
<font color=Blue>控制器的微分方程，差分方程或传递函数。</font>

#### 3.2 控制器C语言代码

```c
typedef struct PID
{   
	float i;
	float d; 
    float Kp;
    float Ki;
    float Kd;
    float setpoint;
    float err;
    float last_err;
    float last_last_err;
	float output;
} pid_t;
pid_t pid;
void pid_Init(pid_t *pid){
	pid -> i=0;
	pid -> d=0;
	pid -> Kp=Kp;
	pid -> Ki=ki;
	pid -> Kd=kd;
	pid -> setpoint=0.00;
	pid -> err=0;
	pid -> last_err=0.00;	
	pid -> last_last_err=0.00;
	pid -> output =0;
}
float PID_Calc(float *Measure,float dt){
	  pid.err=pid.setpoint-*Measure;
		pid.i+=pid.err*dt;
		pid.d=(pid.err-pid.last_err)/dt;
		pid.last_last_err=pid.last_err;
		pid.last_err=pid.err;
		pid.output=pid.Kp*pid.err+pid.Ki*pid.i+pid.Kd*pid.d;
	return pid.output;
}
```

#### <font color=Green>3.3 加入控制器后的simulink仿真结构图</font>

<font color=Blue>在这里放一张simulink仿真结构图并做说明。</font>

#### <font color=Green>3.4 simulink仿真结果</font>

<font color=Blue>把simulink仿真结果放在这里并做说明。</font>

### 四、校验（最重要）

<font color=Blue>将设计的控制器编写成C语言，并在单片机中运行电机仿真程序，观察电机响应曲线。</font>

<font color=Blue>注：即使没有把传递函数建模出来，仍可通过凑试法来确定控制器参数。</font>

#### 4.1 速度闭环

##### （1）系统框图

![37009a6f36391e21aba8acb9b9254fb1](C:\Users\Lenovo\Desktop\pid_test\pictures\37009a6f36391e21aba8acb9b9254fb1.png)

<font color=Blue>绘制系统速度闭环控制框图</font>

##### （2）关键代码

```c
void pidv_Init(pid_t *pid){
	pid -> i=0;
	pid -> d=0;
	if(mode==1&&type==1){
	pid -> Kp=1.00;
	pid -> Ki=2.00;
	pid -> Kd=0.00;
	pid -> setpoint=10.00;
	}
	if(mode==1&&type!=1){
	pid -> Kp=0.65;
	pid -> Ki=0.00;
	pid -> Kd=0.00;
	}
	if(mode==2&&type==1){
	pid -> Kp=8.00;
	pid -> Ki=6.00;
	pid -> Kd=0.00;
	}
	if(mode==2&&type!=1){
	pid -> Kp=8.00;
	pid -> Ki=5.00;
	pid -> Kd=0.00;
	}
	if(mode==3){
	pid -> Kp=3.00;
	pid -> Ki=0.00;
	pid -> Kd=0.00;
	}
	pid -> err=0;
	pid -> last_err=pid -> setpoint;	
	pid -> last_last_err=0.00;
	pid -> output =0;
}
float PID_VCalc(pid_t *pid,float *Measure,float dt){
	  pid->err=pid->setpoint-*Measure;
		pid->i+=pid->err*dt;
		pid->d=(pid->err-pid->last_err)/dt;
		pid->last_last_err=pid->last_err;
		pid->last_err=pid->err;
		pid->output=pid->Kp*pid->err+pid->Ki*pid->i+pid->Kd*pid->d;
	return pid->output;
}
```

##### （3）阶跃响应时域图

![5e5cc161f2c77aba215060f283ea2ff1](C:\Users\Lenovo\Desktop\pid_test\pictures\5e5cc161f2c77aba215060f283ea2ff1.png)

<font color=Blue>放一张图，应至少包含期望速度与速度闭环控制系统实际速度两条曲线。并对比分析结果。</font>

##### （4） 斜坡响应时域图

![2d440a1b13f9b2c1c34f66bc0d4335e0](C:\Users\Lenovo\Desktop\pid_test\pictures\2d440a1b13f9b2c1c34f66bc0d4335e0.png)

<font color=Blue>放一张图，应至少包含期望速度与速度闭环控制系统实际速度两条曲线。并对比分析结果。</font>

##### （5）频率响应时域图

![b9a1083e9834061219e208639cbf9e61](C:\Users\Lenovo\Desktop\pid_test\pictures\b9a1083e9834061219e208639cbf9e61.png)

<font color=Blue>放一张图，应至少包含期望速度与速度闭环控制系统实际速度两条曲线。并对比分析结果。</font>

#### 4.2 角度闭环

##### （1）系统框图

![cf68ca3a19a9b4a9575deebd3294ac7b](C:\Users\Lenovo\Desktop\pid_test\pictures\cf68ca3a19a9b4a9575deebd3294ac7b.png)

<font color=Blue>绘制系统速度闭环控制框图</font>

##### （2）关键代码

```c
void pida1_Init(pid_t *pid){
	pid -> i=0;
	pid -> d=0;
	if(mode==1){
	pid -> Kp=3.00;
	pid -> Ki=0.20;
	pid -> Kd=2.00;
	pid -> setpoint=2*3.1415926;
	}
	if(mode==2){
	pid -> Kp=3.00;
	pid -> Ki=0.00;
	pid -> Kd=0.00;
	}
	if(mode==3){
	pid -> Kp=3.00;
	pid -> Ki=0.20;
	pid -> Kd=2.00;
	}
	pid -> err=0;
	pid -> last_err=pid -> setpoint;	
	pid -> last_last_err=0.00;
	pid -> output =0;
}
void pida2_Init(pid_t *pid){
	pid -> i=0;
	pid -> d=0;
	if(mode==1){
	pid -> Kp=5.00;
	pid -> Ki=0.30;
	pid -> Kd=1.95;
	pid -> setpoint=2*3.1415926;
	}
	if(mode==2){
	pid -> Kp=5.15;
	pid -> Ki=0.00;
	pid -> Kd=0.00;
	}
	if(mode==3){
	pid -> Kp=3.00;
	pid -> Ki=0.20;
	pid -> Kd=2.00;
	}
	pid -> err=0;
	pid -> last_err=pid -> setpoint;	
	pid -> last_last_err=0.00;
	pid -> output =0;
}
float PID_A1Calc(float *Measure,float dt){
	  pida1.err=pida1.setpoint-*Measure;
		pida1.i+=pida1.err*dt;
		pida1.d=(pida1.err-pida1.last_err)/dt;
		pida1.last_last_err=pida1.last_err;
		pida1.last_err=pida1.err;
		pida1.output=pida1.Kp*pida1.err+pida1.Ki*pida1.i+pida1.Kd*pida1.d;
	return pida1.output;
}
float PID_A2Calc(float *Measure,float dt){
	  pida2.err=pida2.setpoint-*Measure;
		pida2.i+=pida2.err*dt;
		pida2.d=(pida2.err-pida2.last_err)/dt;
		pida2.last_last_err=pida2.last_err;
		pida2.last_err=pida2.err;
		pida2.output=pida2.Kp*pida2.err+pida2.Ki*pida2.i+pida2.Kd*pida2.d;
			pidv_a.setpoint=pida2.output;
		pida2.output=PID_VCalc(&pidv_a,&Motor2.MeasureVelocity,dt);
			return pida2.output;
}
```

##### （3）阶跃响应时域图

![2d78d329e80e387cd4dc107aff505dfa](C:\Users\Lenovo\Desktop\pid_test\pictures\2d78d329e80e387cd4dc107aff505dfa.png)

<font color=Blue>放一张图，应至少包含期望角度，单级PID实际角度，串级PID实际角度三条曲线。并对比分析结果。</font>

##### （4）频率响应时域图

![6fd66d355cde58f7e00346dae0d2d4d6](C:\Users\Lenovo\Desktop\pid_test\pictures\6fd66d355cde58f7e00346dae0d2d4d6.png)

<font color=Blue>放一张图，应至少包含期望角度与期望角度，单级PID实际角度，串级PID实际角度三条曲线。并对比分析结果。</font>

##### （5）抗干扰性能时域图

![9b7d0483877670897405f45609bab055](C:\Users\Lenovo\Desktop\pid_test\pictures\9b7d0483877670897405f45609bab055.png)

<font color=Blue>放一张图，应至少包含期望角度，单级PID实际角度，串级PID实际角度三条曲线。并于无干扰的控制情况对比分析结果。</font>



<font color=Blue>提示：建模时难免会有误差，因此控制器参数需要在校验时进行调整。</font>

### 五、扩展内容

### <font color=Green>1、推导该电机系统的传递函数</font>

<font color=Blue>描述建立传递函数的方法、自己的思路以及结果</font>

<font color=Blue>附上设计过程中重要的截图</font>

### <font color=Green>2、复合控制</font>

<font color=Blue>自行查阅资料，采用能想到的方法设计更好的控制器（PID优化，前馈等），从而提高系统的性能。</font>

#### <font color=Green>2.1 控制器设计</font>

<font color=Blue>在这里详细介绍自己选择的控制器。并贴上系统框图</font>

#### <font color=Green>2.2 关键代码</font>

```
//此处粘贴代码
```

#### <font color=Green>2.3 效果展示</font>

（1）角度闭环阶跃响应

<font color=Blue>放一张图，应至少包含期望角度，用传统PID闭环控制的实际曲线和用改进控制器的实际曲线三条曲线。并对比分析结果。</font>

（2）角度闭环频率响应

<font color=Blue>放一张图，应至少包含期望角度，用传统PID闭环控制的实际曲线和用改进控制器的实际曲线三条曲线。并对比分析结果。</font>

（3）角度闭环抗干扰性能

<font color=Blue>放一张图，应至少包含期望角度，用传统PID闭环控制的实际曲线和用改进控制器的实际曲线三条曲线。并对比分析结果。</font>

### <font color=Green>3、滤波</font>

<font color=Blue>在Matlab仿真中给系统的反馈信号叠加噪声，并自行设计滤波器滤除噪声，比较滤波前后的控制效果。</font>
